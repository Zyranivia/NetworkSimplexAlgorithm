\documentclass[11pt,a4paper,twoside,ngerman,openany]{book}
%added for chapter implementation
\usepackage{listings}
\lstset{language=C++,
	basicstyle=\ttfamily,
	keywordstyle=\color{blue}\ttfamily,
	commentstyle=\color{gray}\ttfamily,
	morekeywords={size_t, intmax_t, uintmax_t}
}
\usepackage{xspace}

%added for chapter algorithm
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{mathtools}

\usepackage[shortlabels]{enumitem}

\usepackage[ngerman]{babel}
\usepackage{csquotes}
\usepackage{anyfontsize}
\usepackage[babel]{microtype}

\usepackage{standalone}
\usepackage{pgf, tikz}
\usetikzlibrary{arrows, automata}

\usepackage[hidelinks]{hyperref}
% or colorlinks
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
% in between to suppress warning
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\usepackage{cleveref}

\usepackage{enumitem}
\setdescription{font=\normalfont}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{kor}[thm]{Korollar}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}

\newtheorem*{anm}{Anmerkung}
\newtheorem*{nota}{Notation}

\crefname{thm}{Theorem}{Theoreme}
\crefname{lem}{Lemma}{Lemmata}
\crefname{defn}{Definition}{Definitionen}
\crefname{kor}{Korollar}{Korollare}

\newcommand{\obda}{o.\,B.\,d.\,A. }
\newcommand{\Obda}{O.\,B.\,d.\,A. }
\newcommand{\cpp}{C\texttt{++}\xspace}
\newcommand{\cppelf}{C\texttt{++}11\xspace}

\begin{document}

\chapter{Implementierung} \label{ch:prog}
Der Programmierteil dieser Bachelorarbeit implementiert den Netzwerk-Simplex-Algorithmus wie in \cref{ch:NSA} beschrieben, wobei einzelne Strukturen verändert wurden. Der Code ist in \cpp  geschrieben und hält sich an den \cppelf-Standard. Es folgt eine vollständige Übersicht der Codebestandteile, für das Gesamtkonstrukt siehe TODO Anhang.

\section{Netzwerke}
Zur Umsetzung der Graphenstruktur habe ich eine Klasse \lstinline|class Network| geschrieben, die auf \lstinline|struct Node| sowie \lstinline|class Edge| basiert und den Fluss händelt. Damit kann \lstinline|Network| beispielsweise sicherstellen, dass nie Kanten entfernt werden, die aktuell durchflossen sind.
\subsection{Knoten}
\lstinline|struct Node| hat außer einem Konstruktor keinerlei Funktionen, weswegen es nicht in einer eigenen Klasse ausgelagert, sondern in \lstinline|network.h| enthalten ist. 
\begin{lstlisting}
struct Node {
  size_t id;
  intmax_t b_value;
  //defined by (the other) nodeID
  //always incoming and outgoing due to residual edges
  std::set<size_t> neighbours;

  //constructor
  Node (size_t _id, intmax_t _b_value)
    : id(_id), b_value(_b_value) {};
};
\end{lstlisting}
Ein Knoten wird eindeutig durch seine \lstinline|size_t id| identifiziert, weitere Eigenschaften sind sein b-Wert aus $\mathbb{Z}$ und seine Nachbarknoten. Letztere Menge differenziert nicht zwischen Nachbarn aus eingehenden und ausgehenden Knoten, da diese Unterscheidung im Residualgraphen entfällt.

\subsection{Kanten}
Die Klasse \lstinline|class Edge| enthält alle Informationen über Kanten: Kosten, Kapazität, Fluss und die jeweiligen Endknoten. Residualkanten werden durch das Flag \lstinline|isResidual| gekennzeichnet. An dieser Stelle fällt auf, dass die Kapazität nicht nachträglich verändert werden kann, obwohl dies für Residualkanten notwendig wäre. Ich habe mich in meiner Implementierung dafür entschieden, auf Residualkanten Fluss zu erlauben und damit eine veränderliche Kapazität zu simulieren. Dies wird in TODO näher erläutert.
\begin{lstlisting}
class Edge {
public:
  //edges are initialized with a flow of zero
  Edge (size_t node0, size_t node1, intmax_t cost,
        intmax_t capacity, bool isResidual = false);

  //returns true when flow change was successful
  bool changeFlow (intmax_t value);
  bool changeFlowPossible (intmax_t value);
  //toggles cost betweeen itself and 0
  void toggleCost ();

private:
  size_t node0, node1;
  intmax_t cost, capacity, flow, toggledCost;
  bool isResidual, isToggled = false;
};
\end{lstlisting}
Die Funktion \lstinline|changeFlow| stellt über die Hilfsfunktion \lstinline|changeFlowPossible| sicher, dass bei einer Flussveränderung keine Kapazitätsschranken verletzt werden. Mittels \lstinline|toggleCost| können die Kosten einer Kante zwischen Null und ihrem eigentlichen Wert variiert werden. Somit lässt sich leicht die in \cref{ch:init} beschriebene Low-Cost-Initialisierung umsetzen, siehe dazu \cref{HCLC}.

\subsection{Graph}
Werfen wir einen Blick darauf, wie die Knoten und Kanten in einem Netzwerk gespeichert werden. Ich habe mich dafür entschieden, die Objekte in einer \lstinline|std::map| abzulegen. Die Knoten werden durch ihre \lstinline|size_t id| identifiziert, Kanten durch Anfangsknoten, Endknoten und die \lstinline|bool isResidual|. Ein \lstinline|std::set| benötigt einen Vergleichsoperator, daher habe ich für die Kanten \lstinline|custComp| definiert, das nach \lstinline|size_t node0|, \lstinline|size_t node1| und zuletzt \lstinline|bool isResidual| vergleicht.

Insbesondere ist zu jedem Zeitpunkt zu dem Graph $G$ mit seinem Fluss $f$ der Residualgraph $R_{N,f}$ umgesetzt. TODO wo?

\begin{lstlisting}
class Network {
private:
  intmax_t flow = 0, cost = 0;
  std::vector<size_t> sources, sinks, transit;

  std::map<std::tuple<size_t, size_t, bool>,
           Edge, custComp> edges;
  std::map<size_t, Node, std::less<size_t>> nodes;
};
\end{lstlisting}
Ein Netzwerk kennt außerdem seinen \lstinline|intmax_t flow|, also die Anzahl an Fluss, die von den Quellen zu den Senken transportiert wird, und die dafür anfallenden Kosten \lstinline|intmax_t cost|. Für den Algorithmus ist ersteres nicht relevant, da wir nur auf maximalen Flüssen arbeiten, aber es vereinfacht beispielsweise die Initialisierung.

Die Klasse selbst wird leer oder mit einer Anzahl \lstinline|size_t noOfNodes| von Transitknoten konstruiert und durch Hinzufügen von Knoten und Kanten vervollständigt. Sofern keine Knoten gelöscht werden, ist die \lstinline|size_t id| lückenlos aufsteigend.
\begin{lstlisting}
class Network {
public:
  Network(size_t noOfNodes);

  //return 0 if there's a parallel edge
  //adds residual edge
  bool addEdge(Edge e);
  //returns nodeID
  size_t addNode(intmax_t b_value = 0);

//omitted several get-functions

  //fails and returns 0 if there's flow left
  bool deleteEdge(size_t node0, size_t node1);
  //fails if there's flow on an edge to this node left
  bool deleteNode(size_t nodeID);

  //takes a path from a source to a sink
  //doesn't use residual edges
  bool addFlow(std::vector<size_t>& path, intmax_t flow);
  //takes a circle
  bool changeFlow(Circle& c, intmax_t flow);

  //toggles all edges
  void toggleCost();
};
\end{lstlisting}
Die Funktionen \lstinline|deleteEdge| und \lstinline|deleteNode| schlagen fehl, wenn auf den zu löschenden Kanten noch Fluss ist. So kann unter anderem beim Löschen des künstlichen Knotens überprüft werden, ob die Instanz lösbar ist. Für die Initialisierung nutzen wir die Funktion \lstinline|addFlow|, die einen Weg von einer Quelle zu einer Senke verlangt und somit sicherstellt, dass $\sum_{v\in V(G)} b(v)$ bei unveränderter Knotenmenge gleichbleibt.

\lstinline|changeFlow| wird in jeder Iteration der zweiten Phase des Netzwerk-Simplex-Algorithmus aufgerufen und augmentiert den übergebenen Kreis \lstinline|Circle c| um einen beliebigen Wert, sofern dies möglich ist. Die hier genutzte \lstinline|class Circle| wird im nächsten Kapitel erläutert. Zu guter Letzt wendet \lstinline|toggleCost| die Funktion \lstinline|Edge::toggleCost| für alle Kanten des Netzwerks an.

\section{Die Klasse \emph{Circle}}
Magie des updaten

\section{Stark zulässige Baumlösungen}
Öhm, ja \ldots

\section{Pivotalgorithmen}
Sehr kurz? Probably nur Code

\section{Initialisierung}\label{HCLC}
Beweis LC

\end{document}
\documentclass[11pt,a4paper,twoside,ngerman,openany]{book}
%added for chapter implementation
\usepackage{listings}
\lstset{language=C++,
	basicstyle=\ttfamily,
	keywordstyle=\color{blue}\ttfamily,
	commentstyle=\color{gray}\ttfamily,
	morekeywords={size_t, intmax_t, uintmax_t}
}
\usepackage{xspace}

\newenvironment{tightcenter}{%
    \setlength\topsep{0pt}
    \setlength\parskip{0pt}
    \begin{center}
    }{%
    \end{center}
}

%added for chapter algorithm
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{mathtools}

\usepackage[shortlabels]{enumitem}

\usepackage[ngerman]{babel}
\usepackage{csquotes}
\usepackage{anyfontsize}
\usepackage[babel]{microtype}

\usepackage{standalone}
\usepackage{pgf, tikz}
\usetikzlibrary{arrows, automata}

\usepackage[hidelinks]{hyperref}
% or colorlinks
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
% in between to suppress warning
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\usepackage[nameinlink]{cleveref}

\usepackage{enumitem}
\setdescription{font=\normalfont}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{kor}[thm]{Korollar}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}

\newtheorem*{anm}{Anmerkung}
\newtheorem*{nota}{Notation}

\crefname{thm}{Theorem}{Theoreme}
\crefname{lem}{Lemma}{Lemmata}
\crefname{defn}{Definition}{Definitionen}
\crefname{kor}{Korollar}{Korollare}

\newcommand{\obda}{o.\,B.\,d.\,A. }
\newcommand{\Obda}{O.\,B.\,d.\,A. }
\newcommand{\cpp}{C\texttt{++}\xspace}
\newcommand{\cppelf}{C\texttt{++}11\xspace}

\begin{document}

\chapter{Implementierung} \label{ch:prog}
Der Programmierteil dieser Bachelorarbeit implementiert den Netzwerk-Simplex-Algorithmus wie in \cref{ch:NSA} beschrieben, wobei einzelne Strukturen verändert wurden. Der Code ist in \cpp  geschrieben und hält sich an den \cppelf-Standard. Es folgt eine vollständige Übersicht der Codebestandteile, für das Gesamtkonstrukt siehe TODO Anhang.

\section{Netzwerke}
Zur Umsetzung der Graphenstruktur habe ich eine Klasse \lstinline|class Network| geschrieben, die auf \lstinline|struct Node| sowie \lstinline|class Edge| basiert und den Fluss händelt. Damit kann \lstinline|Network| beispielsweise sicherstellen, dass nie Kanten entfernt werden, die aktuell durchflossen sind.

\subsection{Knoten}
\lstinline|struct Node| hat außer einem Konstruktor keinerlei Funktionen, weswegen es nicht in einer eigenen Klasse ausgelagert, sondern in \lstinline|network.h| enthalten ist. 

\begin{lstlisting}
struct Node {
  size_t id;
  intmax_t b_value;
  //defined by (the other) nodeID
  //always incoming and outgoing due to residual edges
  std::set<size_t> neighbours;

  //constructor
  Node (size_t _id, intmax_t _b_value)
    : id(_id), b_value(_b_value) {};
};
\end{lstlisting}

Ein Knoten wird eindeutig durch seine \lstinline|size_t id| identifiziert, weitere Eigenschaften sind sein b-Wert aus $\mathbb{Z}$ und seine Nachbarknoten. Letztere Menge differenziert nicht zwischen Nachbarn aus eingehenden und ausgehenden Knoten, da diese Unterscheidung im Residualgraphen entfällt.

\subsection{Kanten}
Die Klasse \lstinline|class Edge| enthält alle Informationen über Kanten: Kosten, Kapazität, Fluss und die jeweiligen Endknoten. Residualkanten werden durch das Flag \lstinline|isResidual| gekennzeichnet. An dieser Stelle fällt auf, dass die Kapazität nicht nachträglich verändert werden kann, obwohl dies für Residualkanten notwendig wäre. Ich habe mich in meiner Implementierung dafür entschieden, auf Residualkanten Fluss zu erlauben und damit eine veränderliche Kapazität zu simulieren. Dies wird in \cref{ch:graph} näher erläutert.

\begin{lstlisting}
class Edge {
public:
  //edges are initialized with a flow of zero
  Edge (size_t node0, size_t node1, intmax_t cost,
        intmax_t capacity, bool isResidual = false);

  //returns true when flow change was successful
  bool changeFlow (intmax_t value);
  bool changeFlowPossible (intmax_t value);
  //toggles cost betweeen itself and 0
  void toggleCost ();

private:
  size_t node0, node1;
  intmax_t cost, capacity, flow, toggledCost;
  bool isResidual, isToggled = false;
};
\end{lstlisting}

Die Funktion \lstinline|changeFlow| stellt über die Hilfsfunktion \lstinline|changeFlowPossible| sicher, dass bei einer Flussveränderung keine Kapazitätsschranken verletzt werden. Mittels \lstinline|toggleCost| können die Kosten einer Kante zwischen Null und ihrem eigentlichen Wert variiert werden. Somit lässt sich leicht die in \cref{ch:init} beschriebene Low-Cost-Initialisierung umsetzen, siehe dazu \cref{HCLC}.

\subsection{Graph}\label{ch:graph}
Werfen wir einen Blick darauf, wie die Knoten und Kanten in einem Netzwerk gespeichert werden. Ich habe mich dafür entschieden, die Objekte in einer \lstinline|std::map| abzulegen. Die Knoten werden durch ihre \lstinline|size_t id| identifiziert, Kanten durch Anfangsknoten, Endknoten und die \lstinline|bool isResidual|. Ein \lstinline|std::set| benötigt einen Vergleichsoperator, daher habe ich für die Kanten \lstinline|custComp| definiert, das nach \lstinline|size_t node0|, \lstinline|size_t node1| und zuletzt \lstinline|bool isResidual| vergleicht.

\begin{lstlisting}
class Network {
private:
  intmax_t flow = 0, cost = 0;
  std::vector<size_t> sources, sinks, transit;

  std::map<std::tuple<size_t, size_t, bool>,
           Edge, custComp> edges;
  std::map<size_t, Node, std::less<size_t>> nodes;
};
\end{lstlisting}

Ein Netzwerk kennt außerdem seinen \lstinline|intmax_t flow|, also die Anzahl an Fluss, die von den Quellen zu den Senken transportiert wird, und die dafür anfallenden Kosten \lstinline|intmax_t cost|. Für den Algorithmus ist ersteres nicht relevant, da wir nur auf maximalen Flüssen arbeiten.

Der Graph $G$ mit einem Fluss $f$ und der dazugehörige Residualgraph $G_{N,f}$ werden nicht als zwei verschiedene Objekte der Netzwerk-Klasse geführt, sondern in einer Instanz gemeinsam gespeichert. Um dies zu bewerkstelligen, wird bei jeder Veränderung an einer Kante gleichzeitig die eindeutige Residualkante aktualisiert. Zur Veranschaulichung folgt der Quellcode von \lstinline|Network::addEdge| ohne die Prüfung der Zulässigkeit.

\begin{lstlisting}
bool Network::addEdge(Edge e) {
  std::tuple<size_t, size_t, bool> key
    = std::make_tuple(e.node0, e.node1, e.isResidual);

  //insert both the edge and the residual edge
  edges.insert(std::make_pair(key, e));
  e.invert();
  edges.insert(std::make_pair(invertKey(key), e));

  nodes.find(node0)->second.neighbours.insert(node1);
  nodes.find(node1)->second.neighbours.insert(node0);
  return true;
}
\end{lstlisting}

Dabei vertauscht \lstinline|invertKey| die beiden Knoten und negiert \lstinline|isResidual|. Die oben nicht erwähnte Funktion \lstinline|Edge::invert| spiegelt die Veränderungen von \lstinline|invertKey| und negiert die Kosten gemäß \cref{defRes}. Die Kapazität wird beibehalten, stattdessen wird der Fluss auf \lstinline|flow = capacity - flow;| gesetzt. Der größte Wert, um den die Residualkante $\bar{e}$ augmentiert werden kann, ist also gleich $f(e)$. Sofern wir für $f$ nur Nicht-Residualkanten betrachten, ist diese Implementierung äquivalent zur Definition. Dieser alternative Ansatz fordert noch ein wenig Aufmerksamkeit bei der Klassenfunktion \lstinline|Network::changeFlow|,\footnotemark{} danach können wir bei der Umsetzung des Algorithmus größtenteils ignorieren, ob eine Kante residual ist.

\footnotetext{Für alle Kanten $e$ des Kreises wenden wir \lstinline|e.changeFlow(f)| sowie \lstinline|e.invert().changeFlow(-f)| an und aktualisieren die Kosten auf \lstinline|this->cost += e.cost*f;|.}

Das Netzwerk wird leer oder mit einer Anzahl \lstinline|size_t noOfNodes| von Transitknoten initialisiert und durch Hinzufügen von Knoten und Kanten vervollständigt. Sofern keine Knoten gelöscht werden, ist die \lstinline|size_t id| bei null beginnend lückenlos aufsteigend.

\begin{lstlisting}
class Network {
public:
  Network(size_t noOfNodes);

  bool addEdge(Edge e);
  //returns nodeID
  size_t addNode(intmax_t b_value = 0);
  
  //fails and returns 0 if there's flow left
  bool deleteEdge(size_t node0, size_t node1);
  //fails if there's flow on an edge to this node left
  bool deleteNode(size_t nodeID);

  //takes a path from a source to a sink
  //doesn't use residual edges
  bool addFlow(std::vector<size_t>& path, intmax_t flow);
  //takes a circle
  bool changeFlow(Circle& c, intmax_t flow);
};
\end{lstlisting}

Die Funktionen \lstinline|deleteEdge| und \lstinline|deleteNode| schlagen fehl, wenn auf den zu löschenden Kanten noch Fluss ist. So kann unter anderem durch Löschen des künstlichen Knotens überprüft werden, ob die Instanz lösbar ist. Für Phase 1 des Algorithmus nutzen wir die Funktion \lstinline|addFlow|, die einen Weg von einer Quelle zu einer Senke verlangt und somit sicherstellt, dass $\sum_{v\in V(G)} b(v)$ bei unveränderter Knotenmenge gleichbleibt.

\lstinline|changeFlow| wird in jeder Iteration der zweiten Phase des Netzwerk-Simplex-Algorithmus aufgerufen und augmentiert den übergebenen Kreis \lstinline|Circle c| um einen beliebigen Wert, sofern dies möglich ist. Die hier genutzte \lstinline|class Circle| werden wir uns nun genauer anschauen.

\section{Die Klasse \emph{Circle}}
Magie des updaten

\section{Stark zulässige Baumlösungen}
Öhm, ja \ldots

\section{Pivotalgorithmen}
Sehr kurz? Probably nur Code

\section{Initialisierung}\label{HCLC}
Beweis LC

\end{document}
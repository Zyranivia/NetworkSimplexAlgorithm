\chapter{Implementierung} \label{ch:prog}
Der Programmierteil dieser Bachelorarbeit implementiert den Netzwerk-Simplex-Algorithmus wie in \cref{ch:NSA} beschrieben, wobei einzelne Strukturen verändert wurden. Der Code ist in \cpp  geschrieben und hält sich an den \cppelf-Standard. Es folgt eine vollständige Übersicht der Codebestandteile, für das Gesamtkonstrukt siehe TODO Anhang.

\section{Netzwerke}
Zur Umsetzung der Graphenstruktur habe ich eine Klasse \lstinline|class Network| geschrieben, die auf \lstinline|struct Node| sowie \lstinline|class Edge| basiert und den Fluss händelt. Damit kann \lstinline|Network| beispielsweise sicherstellen, dass nie Kanten entfernt werden, die aktuell durchflossen sind.

\subsection{Knoten}
\lstinline|struct Node| hat außer einem Konstruktor keinerlei Funktionen, weswegen es nicht in einer eigenen Klasse ausgelagert, sondern in \lstinline|network.h| enthalten ist. 

\begin{lstlisting}
struct Node {
  size_t id;
  intmax_t b_value;
  //defined by (the other) nodeID
  //always incoming and outgoing due to residual edges
  std::set<size_t> neighbours;

  //constructor
  Node (size_t _id, intmax_t _b_value)
    : id(_id), b_value(_b_value) {};
};
\end{lstlisting}

Ein Knoten wird eindeutig durch seine \lstinline|size_t id| identifiziert, weitere Eigenschaften sind sein b-Wert aus $\mathbb{Z}$ und seine Nachbarknoten. Letztere Menge differenziert nicht zwischen Nachbarn aus eingehenden und ausgehenden Knoten, da diese Unterscheidung im Residualgraphen entfällt.

\subsection{Kanten}
Die Klasse \lstinline|class Edge| enthält alle Informationen über Kanten: Kosten, Kapazität, Fluss und die jeweiligen Endknoten. Residualkanten werden durch das Flag \lstinline|isResidual| gekennzeichnet. An dieser Stelle fällt auf, dass die Kapazität nicht nachträglich verändert werden kann, obwohl dies für Residualkanten notwendig wäre. Ich habe mich in meiner Implementierung dafür entschieden, auf Residualkanten Fluss zu erlauben und damit eine veränderliche Kapazität zu simulieren. Dies wird in \cref{ch:graph} näher erläutert.

\begin{lstlisting}
class Edge {
public:
  //edges are initialized with a flow of zero
  Edge (size_t node0, size_t node1, intmax_t cost,
        intmax_t capacity, bool isResidual = false);

  //returns true when flow change was successful
  bool changeFlow (intmax_t value);
  bool changeFlowPossible (intmax_t value);
  //toggles cost betweeen itself and 0
  void toggleCost ();

private:
  size_t node0, node1;
  intmax_t cost, capacity, flow, toggledCost;
  bool isResidual, isToggled = false;
};
\end{lstlisting}

Die Funktion \lstinline|changeFlow| stellt über die Hilfsfunktion \lstinline|changeFlowPossible| sicher, dass bei einer Flussveränderung keine Kapazitätsschranken verletzt werden. Mittels \lstinline|toggleCost| können die Kosten einer Kante zwischen Null und ihrem eigentlichen Wert variiert werden. Somit lässt sich leicht die in \cref{ch:init} beschriebene Low-Cost-Initialisierung umsetzen, siehe dazu \cref{HCLC}.

\subsection{Graph}\label{ch:graph}
Werfen wir einen Blick darauf, wie die Knoten und Kanten in einem Netzwerk gespeichert werden. Ich habe mich dafür entschieden, die Objekte für eine logarithmische Laufzeit von \lstinline|find|, \lstinline|insert| sowie \lstinline|delete| in einer \lstinline|std::map| abzulegen. Die Knoten werden durch ihre \lstinline|size_t id| identifiziert, Kanten durch Anfangsknoten, Endknoten und die \lstinline|bool isResidual|. Ein \lstinline|std::set| benötigt einen Vergleichsoperator, daher habe ich für die Kanten \lstinline|custComp| definiert, das nach \lstinline|size_t node0|, \lstinline|size_t node1| und zuletzt \lstinline|bool isResidual| vergleicht.

\begin{lstlisting}
class Network {
private:
  intmax_t flow = 0, cost = 0;
  std::vector<size_t> sources, sinks, transit;

  std::map<std::tuple<size_t, size_t, bool>,
           Edge, custComp> edges;
  std::map<size_t, Node, std::less<size_t>> nodes;
};
\end{lstlisting}

Ein Netzwerk kennt außerdem seinen \lstinline|intmax_t flow|, also die Anzahl an Fluss, die von den Quellen zu den Senken transportiert wird, und die dafür anfallenden Kosten \lstinline|intmax_t cost|. Für den Algorithmus ist ersteres nicht relevant, da wir nur auf maximalen Flüssen arbeiten.

Der Graph $G$ mit einem Fluss $f$ und der dazugehörige Residualgraph $G_{N,f}$ werden nicht als zwei verschiedene Objekte der Netzwerk-Klasse geführt, sondern in einer Instanz gemeinsam gespeichert. Um dies zu bewerkstelligen, wird bei jeder Veränderung an einer Kante gleichzeitig die eindeutige Residualkante aktualisiert. Zur Veranschaulichung folgt der Quellcode von \lstinline|Network::addEdge| ohne die Prüfung der Zulässigkeit.

\begin{lstlisting}
bool Network::addEdge(Edge e) {
  std::tuple<size_t, size_t, bool> key
    = std::make_tuple(e.node0, e.node1, e.isResidual);

  //insert both the edge and the residual edge
  edges.insert(std::make_pair(key, e));
  e.invert();
  edges.insert(std::make_pair(invertKey(key), e));

  nodes.find(node0)->second.neighbours.insert(node1);
  nodes.find(node1)->second.neighbours.insert(node0);
  return true;
}
\end{lstlisting}

Dabei vertauscht \lstinline|invertKey| die beiden Knoten und negiert \lstinline|isResidual|. Die oben nicht erwähnte Funktion \lstinline|Edge::invert| spiegelt die Veränderungen von \lstinline|invertKey| und negiert die Kosten gemäß \cref{defRes}. Die Kapazität wird beibehalten, stattdessen wird der Fluss auf \lstinline|flow = capacity - flow;| gesetzt. Der größte Wert, um den die Residualkante $\bar{e}$ augmentiert werden kann, ist also gleich $f(e)$. Sofern wir für $f$ nur Nicht-Residualkanten betrachten, ist diese Implementierung äquivalent zur Definition. Dieser alternative Ansatz fordert noch ein wenig Aufmerksamkeit bei der Klassenfunktion \lstinline|Network::changeFlow|,\footnotemark{} danach können wir bei der Umsetzung des Algorithmus größtenteils ignorieren, ob eine Kante residual ist.

\footnotetext{Für alle Kanten $e$ des Kreises wenden wir \lstinline|e.changeFlow(f)| sowie \lstinline|e.invert().changeFlow(-f)| an und aktualisieren die Kosten auf \lstinline|this->cost += e.cost*f;|.}

Das Netzwerk wird leer oder mit einer Anzahl \lstinline|size_t noOfNodes| von Transitknoten initialisiert und durch Hinzufügen von Knoten und Kanten vervollständigt. Sofern keine Knoten gelöscht werden, ist die \lstinline|size_t id| bei null beginnend lückenlos aufsteigend.

\begin{lstlisting}
class Network {
public:
  Network(size_t noOfNodes);

  bool addEdge(Edge e);
  //returns nodeID
  size_t addNode(intmax_t b_value = 0);
  
  //fails and returns 0 if there's flow left
  bool deleteEdge(size_t node0, size_t node1);
  //fails if there's flow on an edge to this node left
  bool deleteNode(size_t nodeID);

  //takes a path from a source to a sink
  //doesn't use residual edges
  bool addFlow(std::vector<size_t>& path, intmax_t flow);
  //takes a circle
  bool changeFlow(Circle& c, intmax_t flow);
};
\end{lstlisting}

Die Funktionen \lstinline|deleteEdge| und \lstinline|deleteNode| schlagen fehl, wenn auf den zu löschenden Kanten noch Fluss ist. So kann unter anderem durch Löschen des künstlichen Knotens überprüft werden, ob die Instanz lösbar ist. Für Phase 1 des Algorithmus nutzen wir die Funktion \lstinline|addFlow|, die einen Weg von einer Quelle zu einer Senke verlangt.

\lstinline|changeFlow| wird in jeder Iteration der zweiten Phase des Netzwerk-Simplex-Algorithmus aufgerufen und augmentiert den übergebenen Kreis \lstinline|Circle c| um einen beliebigen Wert, sofern dies möglich ist. Dieser Wert wird analog zur $\delta$ aus \cref{ch:NSA} der größte zulässige sein. Die hier genutzte \lstinline|class Circle| werden wir uns nun genauer anschauen.

\section{Die Klasse \emph{Circle}}
Sei $G$ ein gerichteter Graph mit $n$ Knoten sowie $m$ Kanten und $T$ ein aufspannender Baum von $G$. In der Herleitung des Algorithmus haben wir genutzt, dass für eine Kante $e\in E(G)\backslash E(T)$ außerhalb des Baumes der Kreis $C_{T,e}$ eindeutig ist. Ein Kreis $C_{T,e}$ lässt sich in Laufzeit $\bigO(n)$ berechnen, womit wir pro Iteration bei einer Komplexität von $\bigO(n\cdot(m-n)\cdot \text{poly}(n,m))$\footnotemark{} für Laufzeit $\text{poly}(n,m)$ des Pivotalgorithmus sind.

\footnotetext{Wie in \cref{ch:pivot} erwähnt, betrachten wir Pivotalgorithmen, die sämtliche Kreise in ihre Entscheidung einbeziehen.}

Im Normalfall verändern sich von einer Iteration auf die nächste nur ein Bruchteil der Kreise. Diese lassen sich jedoch schlecht herausfiltern, wenn nur die Veränderung der zulässigen Baumlösung betrachtet wird. Daher habe ich mich entschieden, nach \cite{betreuer} nicht den Baum abzuspeichern, sondern alle Kreise. Die Klasse \lstinline|class Circle| speichert gerichtete Kreise als zwei Vektoren (\lstinline|std::vector|), die Kanten wie gehabt über Anfangsknoten, Endknoten und die \lstinline|bool isResidual| identifizieren. Außerdem speichern sie ihre jeweiligen Werte für $\delta$ und $c(\bar{C}_{T,e})$; diese müssen jedoch vom Algorithmus gesetzt werden.

Nicht explizit in der Klassendeklaration schlägt sich die Invariante nieder, dass im Verlauf des Algorithmus jeder Kreis durch die erste Kante als einzige Nichtbaumkante spezifiziert wird.

\begin{lstlisting}[escapechar=ß]
//first edge of edges is not part of the underlying tree
class Circle {
public:
  //circles don't know about their graphs
  intmax_t flow = 0, costPerFlow = 0;

private:
  std::vector<std::pair<size_t, size_t>> edges;
  //std::vector<char>, because std::vector<bool> is brokenß\footnotemarkß
  std::vector<char> isResidual;
};
\end{lstlisting}

Bevor wir uns die Umsetzung anschauen, überlegen wir uns theoretisch, was die Klasse leisten muss. Dazu betrachten wir eine Iteration, in der $C_1=\bar{C}_{T,e_1}$ ausgewählt wurde. Sei $C_2=\bar{C}_{T,e_2}$ mit $e_1\neq e_2$ ein weiterer Kreis. \cref{fig:circles} stellt für die zugrundeliegenden ungerichteten Kreise $\tilde{C}_1$ und $\tilde{C}_2$ dar, wie sich $C_1$ und $C_2$ zueinander verhalten können.

\footnotetext{Für mehr Informationen siehe \cite[\textit{Item 18: Avoid using} \texttt{vector<bool>}]{STL}.}

\begin{figure}[!ht]\centering
    \includestandalone{tikz_circlesupdate}
    \caption{Beide Beispiele zeigen je zwei Kreise $\tilde{C}_i=C_{T,e_i}$, wobei $e_i$ die gestrichelte Kante ist. Alle anderen Kanten gehören zum nicht vollständig dargestellten Baum $T$. Im zweiten Fall sind $\tilde{C}_1$ und $\tilde{C}_2$ nicht disjunkt.}
    \label{fig:circles}
\end{figure}

Der Algorithmus wird nun $e_i$ zum neuen Baum $T'$ hinzufügen und eine ausgehende Kante $e_i\neq e'\in E(C_{T,e_1})$ wählen, die dafür entfernt wird. Zunächst halten wir fest, dass es vor der Iteration keinen weiteren Fall als die beiden aus \cref{fig:circles} geben kann: Wären $e_1$ und $e_2$ im Schnitt der ungerichteten Kreise $E(C_{T,e_1})\cap E(C_{T,e_2})$ enthalten, dann wäre $T$ nicht kreisfrei.

Für den neuen ungerichteten Kreis gilt $C_{T',e'}=C_{T,e_1}$, zur Beibehaltung der Invariante muss \lstinline|class Circle| die gespeicherten Kanten rotieren. Für die Konstellation, dass $e_1$ im Gegensatz zu $e'$ nicht saturiert ist oder vice versa ändert sich zusätzlich die Richtung von $\bar{C}_{T',e'}$ im Vergleich zu $\bar{C}_{T,e_1}$. All dies leistet die Funktion \lstinline|Circle::rotateBy|:

\begin{lstlisting}
void Circle::rotateBy (size_t index, bool toReverse) {
  //rotate, such that the correct edge is on front
  std::rotate(edges.begin(),
              edges.begin()+index, edges.end());
  std::rotate(isResidual.begin(),
              isResidual.begin()+index, isResidual.end());
  //all but the first entry have to be reversed in position
  if (toReverse) {
    //change direction of all edges
    for (size_t i = 0; i < this->length; i++) {
      std::swap(edges[i].first, edges[i].second);
      isResidual[i] = not isResidual[i];
    }
    std::reverse(edges.begin() + 1, edges.end());
    std::reverse(isResidual.begin() + 1, isResidual.end());
    }
}
\end{lstlisting}

Der einfache Fall a) aus \cref{fig:circles} ist damit abgehandelt, da $C_2$ unverändert bleibt. Die gilt ebenfalls für Fall b), insofern $e'\notin E(C_{T,e_1})\cap E(C_{T,e_2})$. Andernfalls TODO XOR der ungerichteten Kreis, Orientierung ergibt sich (Bild tikzen!)!

\newpage
\begin{lstlisting}[basicstyle=\small]
void Circle::update(Circle& c) {
  bool iR = c.getIsResidual()[0];
  std::pair<size_t, size_t> edgeSame = c.getEdges()[0];
  std::pair<size_t, size_t> edgeReverse = std::make_pair(edgeSame.second, edgeSame.first);

  bool reversed = false;
  size_t index = 0;
  std::vector<std::pair<size_t, size_t>>::iterator it = edges.begin();
  //find edgeSame if existent
  for (index = 0; it != edges.end(); index++) {
    if (iR == isResidual[index] and edges[index] == edgeSame) {break;}
  it++;
  }
  //if edgeSame is in this->edges, reverse c, do second if-case
  //and reverse back
  if (it != edges.end()) {
    c.rotateBy(0, true);
    reversed = true;
  }
  //else try to find edgeReverse
  else {
    it = edges.begin();
    for (index = 0; it != edges.end(); index++) {
      if (iR != isResidual[index] and edges[index] == edgeReverse) {break;}
      it++;
    }
  }

  //redirect this circle over c
  if (reversed or  it != edges.end()) {
    std::vector<bool> toCopy (c.length, true);
    size_t indexLeft = index - 1, indexRight = index + 1;
    
    //take out all edges existent in both circles
    toCopy[0] = false; //first edge not even in tree
    //left from first edge
    for (; indexLeft > 0; indexLeft--) {
      //circles are in opposite directions, so reverse the edge for existence check
      std::pair<size_t, size_t> checkEdge =
      std::make_pair(c.getEdges()[index - indexLeft].second, c.getEdges()[index - indexLeft].first);
      iR = c.getIsResidual()[index - indexLeft];
      if (iR != isResidual[indexLeft] and edges[indexLeft] == checkEdge) {toCopy[index - indexLeft] = false;}
      else {break;}
    }
    //right from first edge
    for (; indexRight < this->length; indexRight++) {
      //circles are in opposite directions, so reverse the edge for existence check
      std::pair<size_t, size_t> checkEdge =
      std::make_pair(c.getEdges()[c.length + index - indexRight].second, c.getEdges()[c.length + index - indexRight].first);
      iR = c.getIsResidual()[c.length + index - indexRight];
      if (iR != isResidual[indexRight] and edges[indexRight] == checkEdge) {toCopy[c.length + index - indexRight] = false;}
      else {break;}
    }
    
    //construct new circle
    std::vector<std::pair<size_t, size_t>> edgesNew;
    std::vector<char> isResidualNew;
    
    //first part of old circle
    for (size_t i = 0; i <= indexLeft; i++) {
      edgesNew.push_back(this->edges[i]);
      isResidualNew.push_back(this->isResidual[i]);
    }
    //bypass
    for (size_t i = 0; i < c.length; i++) {
      if (toCopy[i]) {
        edgesNew.push_back(c.getEdges()[i]);
        isResidualNew.push_back(c.getIsResidual()[i]);
      }
    }
    //last part of old circle
    for (size_t i = indexRight; i < this->length; i++) {
      edgesNew.push_back(this->edges[i]);
      isResidualNew.push_back(this->isResidual[i]);
    }
    
    this->edges = edgesNew;
    this->isResidual = isResidualNew;
  }

  //reverse back
  if(reversed) {c.rotateBy(0, true);}
  length = edges.size();
}
\end{lstlisting}
\newpage

\section{Stark zulässige Baumlösungen}
Öhm, ja \ldots

\section{Pivotalgorithmen}
Sehr kurz? Probably nur Code

\section{Initialisierung}\label{HCLC}
Beweis LC
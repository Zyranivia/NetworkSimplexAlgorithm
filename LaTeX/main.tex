\documentclass[a4paper,twoside,ngerman]{report}
\author{Max~Kanold}
\title{Experimentelle Ergebnisse zum Network-Simplex-Algorithmus}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{pgf, tikz}
\usetikzlibrary{arrows, automata}

\usepackage{mathtools}

\usepackage[shortlabels]{enumitem}

\usepackage[ngerman]{babel}
\usepackage{csquotes}
\usepackage{anyfontsize}
\usepackage[babel]{microtype}

\usepackage[hidelinks]{hyperref}
% or colorlinks
\usepackage{amssymb,amsthm}
% in between to suppress warning
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\usepackage{cleveref}

\usepackage{enumitem}
\setdescription{font=\normalfont\itshape}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{kor}[thm]{Korollar}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}

\newtheorem*{anm}{Anmerkung}
\newtheorem*{nota}{Notation}

\crefname{thm}{Theorem}{Theoreme}
\crefname{lem}{Lemma}{Lemmata}
\crefname{defn}{Definition}{Definitionen}
\crefname{kor}{Korollar}{Korollare}

\newcommand{\obda}{o.\,B.\,d.\,A. }
\newcommand{\Obda}{O.\,B.\,d.\,A. }

\begin{document}
\maketitle
\tableofcontents

\newpage
\chapter{Einführung}
Das Simplex-Verfahren, zu welchem eine Einführung in \cite{NSAbook} gefunden werden kann, löst Lineare Programme in der Praxis sehr schnell, obwohl die Worst-Case-Laufzeit nicht polynomiell ist. Jedes Netzwerkproblem lässt sich als Lineares Programm darstellen und somit durch das Simplex-Verfahren lösen, durch die konkrete Struktur solcher Probleme genügt jedoch der von \cite[Dantzig, 1951]{erf1} und \cite[Orden, 1956]{erf2} vereinfachte Network-Simplex-Algorithmus. Auch für diesen gibt es exponentielle Instanzen (siehe \cref{ch:lit}), in der Praxis wird er trotzdem vielfach verwendet.

TODO Legende für Graphen einführen

TODO Laufzeit definieren: Iterationsanzahl, obwohl in der Praxis Pivot relevant

\newpage
\chapter{Netzwerk-Simplex-Algorithmus}
Zunächst führen wir in \cref{ch:MCF} das Transportproblem und dessen Verallgemeinerung auf beschränkte Kapazitäten ein. Gleichzeitig geben wir die Einschränkungen an, auf denen insbesondere der Programmierteil dieser Bachelorarbeit fußt. Die Beschreibung des Netzwerk-Simplex-Algorithmus in \cref{ch:alg} orientiert sich zuerst an \cite[S. 291\,ff.]{NSAbook} zur Lösung des Transportproblems, danach wird in \cref{ch:alg2} der Algorithmus anhand von \cite[S. 353\,ff.]{NSAbook} auf den allgemeinen Fall erweitert.

\section{Min-Cost-Flow-Problem}\label{ch:MCF}
\begin{defn}Ein \textbf{Netzwerk} ist ein Tupel $(G,b,c,u)$, wobei $G = (V,E)$ ein gerichteter Graph, $b : V\rightarrow\mathbb{R}$ eine b-Wert-Funktion, $c : E\rightarrow\mathbb{R}$ eine Kostenfunktion und $u : E\rightarrow\mathbb{R}_{\geq 0}\cup \infty$ eine Kapazitätsfunktion seien.\end{defn}
\begin{anm}Knoten mit positiven b-Wert werden als Quellen, solche mit negativen als Senken bezeichnet.\\
Ein ungerichteter Graph kann durch das Verwandeln jeder Kante $\{v,w\}$ in zwei Kanten $(v,w)$ und $(w,v)$ zu einem gerichteten modifiziert werden.\end{anm}

\begin{defn}\label{DefMaxFlow}Ein \textbf{maximaler Fluss} auf einem Netzwerk $(G=(V,E),b,c,u)$ ist eine Abbildung $f : E\rightarrow\mathbb{R}_{\geq 0}$, die folgende Eigenschaften erfüllt:
\begin{enumerate}[(i)]
\item $\forall e\in E : f(e)\leq u(e) $
\item $\forall v\in V : \sum_{(w,v)\in E} f((w,v)) - \sum_{(v,w)\in E} f((v,w)) + b(v) = 0$\label{DefMaxFlowII}
\end{enumerate}
Der \emph{Wert} von $f$ ist
$v(f) = \frac{1}{2}\cdot\sum_{v\in V} |b(v)|$\\
und die \emph{Kosten} von $f$ sind
$c(f) = \sum_{e\in E} f(e)\cdot c(e)$.
\end{defn}

Beim \emph{Min-Cost-Flow-Problem} wird unter allen maximalen Flüssen einer mit minimalen Kosten gesucht. Sind die Kapazitäten unbeschränkt, so wird es als \emph{Transportproblem} bezeichnet.

In dieser Bachelorarbeit wird angenommen, dass $b$ auf $\mathbb{Z}$ sowie $c$ und $u$ auf $\mathbb{N}_0$ abbilden, um Gleitkommazahlungenauigkeit beim Programmieren zu vermeiden. Durch eine entsprechende Skalierung des Problems können die Funktionen nach $\mathbb{R}$ bzw. $\mathbb{R}_{\geq 0}$ hinreichend genug angenähert werden. Durch die eingeschränkte Kostenfunktion hat kein maximaler Fluss negative Kosten; es gibt keine unbeschränkten Instanzen. Unbeschränkte Kapazitäten können somit \obda durch $\frac{1}{2}\cdot\sum_{v\in V} |b(v)| + 1$ abgeschätzt werden.

Zusätzlich wird davon ausgegangen, dass $\sum_{v\in V(G)} b(v) = 0$ ist, Angebot und Nachfrage also ausgeglichen sind. Des Weiteren ist in der konkreten Implementierung $E$ keine Multimenge; es sind keine parallelen Kanten vorgesehen. Alle Netzwerke werden als zusammenhängend angenommen, da die Zusammenhangskomponenten einer Instanz einzeln gelöst werden können. Der programmierte Algorithmus verlangt keinen Zusammenhang.

\section{Der grundlegende Algorithmus}\label{ch:alg}
Um die Funktionsweise des Netzwerk-Simplex-Algorithmus zu definieren, benötigen wir zuerst einige grundlegende Definitionen der Graphentheorie. Im Nachfolgenden sind nur die wichtigsten in Kürze aufgeführt, für eine vollständige Einführung sei der geneigte Leser auf \cite{Alma} verwiesen.

\begin{defn}Der einem gerichteten Graphen $G=(V,E)$ \textbf{zugrundeliegende ungerichtete Graph} $G'=(V,E')$ ist definiert durch:
\begin{equation*}\{v,w\}\in E' \iff (v,w) \in E \lor (w,v) \in E\end{equation*} \end{defn}
\begin{anm}Nach dieser Definition gibt es keine Bijektion zwischen gerichteten und den zugrundeliegenden ungerichteten Graphen; dafür vermeidet man parallele Kanten.\end{anm}

\begin{defn}Ein \textbf{Baum} $T$ ist ein ungerichteter, zusammenhängender und kreisfreier Graph. Ein \textbf{Wald} ist ein Graph, bei dem jede Zusammenhangskomponente ein Baum ist.\\
Ein Teilgraph $T=(V',E')$ eines ungerichteten Graphen $G=(V,E)$ heißt \textbf{aufspannender Baum}, wenn T ein Baum und $V'=V$ ist.\end{defn}
\begin{anm}Sprechen wir bei einem gerichteten Graphen $G$ über einen Wald bzw. (aufspannenden) Baum, so bezieht sich das stets auf einen Teilgraphen $T$ von $G$, dessen zugrundeliegender ungerichteter Graph ein Wald bzw. (aufspannender) Baum des $G$ zugrundeliegenden ungerichteten Graphen ist.\end{anm}

\begin{defn}Sei $N=(G,b,c,u)$ eine Instanz des Transportproblems. Ein aufspannender Baum $T$ von $G$ und ein maximaler Fluss $f$ auf $N$ bilden eine \textbf{zulässige Baumlösung} $(T,f)$, wenn $\forall e\in E(G)\backslash E(T): f(e) = 0$.\end{defn}

\begin{lem}\label{TreeUnique}Jede zulässige Baumlösung $(T,f)$ ist eindeutig durch den aufspannenden Baum $T$ definiert.\end{lem}
\begin{proof}Sei $(T=(V,E),f)$ eine zulässige Baumlösung einer Instanz des Transportproblems. Für jedes Blatt von $l\in V$ sei $e_l\in E$ die eindeutige Kante in $T$ zwischen den Knoten $k$ und $l$. Für alle Blätter $l$ ist der Wert von $f(e_l)$ nach \cref{DefMaxFlow} \cref{DefMaxFlowII} eindeutig.
	
Wir entfernen nun alle mit Fluss belegten Kanten $e_l$ sowie die nun isolierten Knoten $l$ und aktualisieren den b-Wert von $k$. Der dabei entstehende Graph $T'=(V'\subseteq V,E'\subseteq E)$ bleibt weiterhin ein aufspannender Baum und $f_{|E'}$ ein maximaler Fluss. Durch Iteration ist $f$ wohldefiniert und eindeutig.\end{proof}

Wie \cref{fig:augm} veranschaulicht, gibt es maximale Flüsse, zu denen wir keine zulässige Baumlösung finden können. Auch wenn wir uns auf die maximalen Flüsse beschränken, zu denen es zulässige Baumlösungen gibt, gilt die Gegenrichtung nach \cref{fig:augm} nicht.

\begin{figure}[!h]\centering
\begin{tikzpicture} [align=center]
\path (0, 0) node[circle, draw, text width=0.42cm] (v0) {$-2$}
 	  (3, 0) node[circle, draw, text width=0.42cm] (v1) {$0$}
	  (1.5, 1.5) node[circle, draw, text width=0.42cm] (v2) {$2$};
	  
\draw[->] (v0) -- node [sloped, anchor=center, below] {\tiny \textcolor{blue}{1}, \textcolor{red}{1}} (v1);
\draw[->] (v0) -- node [sloped, anchor=center, above] {\tiny \textcolor{blue}{1}, \textcolor{red}{2}} (v2);
\draw[->] (v1) -- node [sloped, anchor=center, above] {\tiny \textcolor{blue}{1}, \textcolor{red}{1}} (v2);

\path (6, 0) node[circle, draw, text width=0.42cm] (v3) {$-2$}
	  (9, 0) node[circle, draw, text width=0.42cm] (v4) {$0$}
	  (7.5, 1.5) node[circle, draw, text width=0.42cm] (v5) {$2$};
\draw[->] (v3) -- node [sloped, anchor=center, below] {\tiny \textcolor{blue}{0}, \textcolor{red}{1}} (v4);
\draw[->] (v3) -- node [sloped, anchor=center, above] {\tiny \textcolor{blue}{2}, \textcolor{red}{2}} (v5);
\draw[->] (v4) -- node [sloped, anchor=center, above] {\tiny \textcolor{blue}{0}, \textcolor{red}{1}} (v5);
\end{tikzpicture}
\caption{Links ein maximaler Fluss ohne zulässige Baumlösung, rechts ein maximaler Fluss mit uneindeutiger zulässiger Baumlösung.\protect\\
\protect\textit{Legende.} b-Wert: schwarz im Knoten, Fluss: \protect\textcolor{blue}{blau} auf Kante, Kosten: \protect\textcolor{red}{rot} auf Kante}
\label{fig:augm}
\end{figure}

Wie wir in \cref{minCostFlow} zeigen werden, existiert eine zulässige Baumlösung $(T,f)$, sodass $c(f)$ minimal ist. Die dem Algorithmus zugrundeliegende Idee ist es, über die Bäume zulässiger Baumlösungen mit sinkenden Kosten zu iterieren. Der Übergang basiert dabei auf dem Augmentieren negativer Kreise, eine Methode, für die das Konzept des Residualgraphen hilfreich ist.

\begin{defn}\label{defRes}Sei $N=(G=(V,E),b,c,u)$ ein Netzwerk mit einem maximalen Fluss $f$. Die \textbf{Residualkante} $\bar{e}$ einer Kante $e=(v,w)\in E$ verläuft von $w$ nach $v$. Sei $\bar{E}=\{\bar{e}|e\in E\}$ die Menge aller Residualkanten. Die \textit{Residualkapazität} $u_f:\bar{E}\rightarrow\mathbb{Z}$ ist bestimmt durch $u_f(\bar{e})=f(e)$, die \textit{Residualkosten} $c_f:\bar{E}\rightarrow\mathbb{Z}$ durch $c_f(\bar{e})=-c(e)$.

Der \textbf{Residualgraph} $R$ ist ein Tupel $R_{N,f}=(\bar{G}=(V,E\amalg\bar{E}),\bar{f},b,\bar{c},\bar{u})$ mit dem gerichteten Multigraphen $\bar{G}$ aus der bisherigen Knotenmenge und der disjunkten Vereinigung von Kanten und Residualkanten, dem maximalen Fluss $\bar{f}$ mit $\bar{f}(e)=f(e)$ für alle $e\in E$ und $\bar{f}(\bar{e})=0$ für alle $\bar{e}\in\bar{E}$, der b-Wert-Funktion $b$ wie gehabt, der Kostenfunktion $\bar{c}=c\amalg c_f:E\amalg\bar{E}\rightarrow\mathbb{Z}$ und der Kapazitätsfunktion $\bar{u}=u\amalg u_f:E\amalg\bar{E}\rightarrow\mathbb{Z}$. 
\end{defn}

Erhöht man in einem Residualgraphen $R_{N,f}$ den Fluss einer Residualkante $\bar{e}$ um $0\leq\delta\leq u_f(\bar{e})$, so entspricht das der Flussreduktion der dazugehörigen Kante $e$ in $N$ um $\delta$. Nach obiger Definition ist sichergestellt, dass $f(e)-\delta\geq0$.

Augmentieren wir in einem Residualgraphen $R_{N,f}$ einen gerichteten Kreis $C\subseteq G$, erhöhen also für alle Kanten $e\in E(C)$ den Fluss um einen festen Betrag $\delta\in\mathbb{N}_0$, ohne Kapazitätsschranken zu verletzen, erhalten wir einen neuen maximalen Fluss $f'$ in $N$. Seine Kosten betragen $c(f')=c(f) + \delta\cdot(\sum_{e\in C} \bar{c}(e))$.

\begin{lem}\label{negKreis}Sei $N$ eine Instanz des Transportproblems, $R_{N,f}$ ihr Residualgraph und $C$ ein Kreis in $R_{N,f}$ mit negativen Kosten. Der größte Wert $\delta$, um den $C$ augmentiert werden kann, ist endlich, und nach der Augmentierung um $\delta$ zum neuen maximalen Fluss $f'$ existiert eine Residualkante $\bar{e}\in C$, sodass die korrespondierende Kante $e$ einen Fluss von $f'(e)=0$ besitzt. 
\end{lem}
\begin{proof}Sei $N=((V,E),b,c,u)$ ein Instanz des Transportproblems mit maximalen Fluss $f$ und $C$ ein negativer Kreis in $R_{N,f}$. Da $c:E\rightarrow\mathbb{N}_0$ in die natürlichen Zahlen abbildet, enthält jeder negative Kreis in $R_{N,f}$ mindestens eine Residualkante $\bar{e}$. Damit ist $0\leq\delta\leq u_f(\bar{e})<\infty$.
	
Sei nun $\delta:=\min_{e\in C}\{\bar{u}(e)-\bar{f}(e)\}$ größtmöglich gewählt. Da alle Kanten $e\in E$ unbeschränkte Kapazität haben und ihr Fluss $f(e)$ endlich ist, gibt es eine Residualkante $\bar{e}$ mit $u_f(\bar{e})=\delta$. Augmentiert man $C$ um $\delta$ zu einem maximalen Fluss $f'$, ist der neue Fluss auf der korrespondierenden Kante $f'(e)=f(e)-\delta=f(e)-u_f(\bar{e})=f(e)-f(e)=0$.\end{proof}

\begin{nota}Sei $f$ ein maximaler Fluss für ein Netzwerk $(G=(V,E),b,c,u)$ und $H=(V'\subseteq V, E'\subseteq E)$ ein Teilgraph. Mit $H_f=(V',E''=\{e\in E' | f(e) \neq 0\})$ bezeichnen wir den Graph aller durchflossenen Kanten.\end{nota}

Dank \cref{negKreis} wissen wir, dass nach maximaler Augmentierung eines negativen Kreises $C$ alle seine durchflossenen Kanten $C_f$ einen Wald bilden. Damit können wir nun zeigen, dass eine zulässige Baumlösung $(T,f)$ mit einem maximalen Fluss $f$ minimaler Kosten existiert.

\begin{thm}\label{BLex}Sei $N$ eine Instanz des Transportproblems mit einem maximalen Fluss $f$. Es existiert ein maximaler Fluss $\hat{f}$, sodass $c(\hat{f})\leq c(f)$ ist und eine zulässige Baumlösung $(\hat{T},\hat{f})$ existiert.\end{thm}
\begin{proof}Sei $N=(G,b,c,u)$ ein Instanz des Transportproblems mit maximalen Fluss $f$. Wir werden $f$ zu einem maximalen Fluss $\hat{f}$ umwandeln, sodass $G_{\hat{f}}$ ein Wald ist. Für $\hat{f}$ finden wir dann leicht eine zulässige Baumlösung. Wenn wir für die endlich vielen maximalen Zwischenflüsse $f=f_0,f_1,f_2,\ldots,f_n=\hat{f}$ sicherstellen, dass $c(f_{i+1})\leq c(f_i)$ ist, gilt auch $c(\hat{f})\leq c(f)$.

Betrachte einen maximalen Fluss $f_i$. Wenn $G_{f_i}$ ein Wald ist, setzen wir $\hat{f}:=f_i$ und sind fertig. Ansonsten gibt es einen ungerichteten Kreis $C$ in $G_{f_i}$. Betrachte die beiden dazugehörigen, gerichteten, kantendisjunkten Kreise $C_1$ und $C_2$ in $R_{N,f_i}$. Nach \cref{defRes} gilt $c(C_1)=-c(C_2)$.
\begin{description}
\item[Fall 1:] $c(C_1)=0$\\
	Mindestens einer der beiden Kreise enthält eine Residualkante, sei dies \obda $C_1$. Augmentiere nun $C_1$ analog zum Beweis von \cref{negKreis} größtmöglich zu einem maximalen Fluss $f_{i+1}$. Damit ist $C\nsubseteq G_{f_{i+1}}$ und $c(f_{i+1}) = c(f_i)$.
\item[Fall 2:] $c(C_1)\neq0$\\
	\Obda sei $c(C_1)<0$. Nach \cref{negKreis} erhalten wir einen maximalen Fluss $f_{i+1}=f'$, sodass $C\nsubseteq G_{f_{i+1}}$ und $c(f_{i+1}) = c(f_i) + \delta\cdot c(C_1)<c(f_i)$.
\end{description}

Damit ist $G_{f_{i+1}}\subsetneq G_{f_i}$ sowie $c(f_{i+1})\leq c(f_i)$. Nach endlich vielen Iterationen erhalten wir somit $\hat{f}$.
\end{proof}

\begin{kor}\label{minCostFlow}Für jede lösbare Instanz des Transportproblems existiert eine zulässige Baumlösung $(T,f)$, sodass der maximale Fluss $f$ minimale Kosten hat.\qed\end{kor}

\begin{nota}Sei $N=(G,b,c,u)$ ein Netzwerk, $T$ ein aufspannender Baum von $G$ und $e\in E(G)\backslash E(T)$ eine weitere Kante. Mit $C_{T,e}$ bezeichnen wir den eindeutigen Teilgraph von $T\cup\{e\}$, dessen zugrundeliegender Graph ein Kreis ist, und mit  $\bar{C}_{T,e}$ den eindeutigen gerichteten Kreis in $R_{N,f}$ zu $C_{T,e}$, der $e$ enthält.\end{nota}

Sei $N=(G,b,c,u)$ eine Instanz des Transportproblems. Wie beim Simplex-Algorithmus gibt es beim Netzwerk-Simplex-Algorithmus zwei Phasen. In der ersten wird eine initiale zulässige Baumlösung $(T_0,f_0)$ auf $N$ erzeugt; die beiden etablierten Vorgehensweisen werden in \cref{ch:init} beschrieben. Die Problematik einer Instanz ohne Lösung wird ebenfalls dort behandelt. Die zweite Phase iteriert folgende Vorgehensweise:

Betrachte Iteration $i$ mit zulässiger Baumlösung $(T_i,f_i)$. Wähle einen negativen Kreis $\bar{C}_{T,e}$. Existiert kein solcher, beende den Algorithmus. Andernfalls augmentiere $\bar{C}_{T,e}$ größtmöglich zum maximalen Fluss $f_{i+1}$; jetzt existiert nach \cref{negKreis} eine Kante $e\neq e'\in C_{T,e}$ mit $f_{i+1}(e')=0$. Die neue zulässige Baumlösung sei dann $(T_{i+1}=T_i\backslash\{e'\}\cup\{e\},f_{i+1})$. Die verschiedenen Möglichkeiten zur Wahl von $e$ und $e'$ werden in \cref{ch:pivot} und \cref{ch:deg} näher beleuchtet.

Wir werden nun beweisen, dass der Algorithmus eine optimale Lösung des Transportproblems gefunden hat, wenn Phase 2 in Ermangelung einer geeigneten Kante $e$ beendet wird.

\begin{nota}Sei $N=(G,b,c,u)$ ein Netzwerk mit einem maximalen Fluss $f$, $T$ ein aufspannender Baum von $G$ und $v,w\in V(G)$ zwei beliebige Knoten. Mit $v\xrightarrow{T}w$ bezeichnen wir den eindeutigen gerichteten Weg von $v$ nach $w$ in $R_{N,f}$, der nur über Kanten $e\in E(T)$ oder deren Residualkanten $\bar{e}$ verläuft. Insbesondere ist dieser Weg unabhängig von $f$ und für die Kosten gilt $c(w\xrightarrow{T}v) = -c(v\xrightarrow{T}w)$.\end{nota}

\begin{thm}Sei $N$ eine Instanz des Transportproblems mit einer zulässigen Baumlösung $(T,f)$. Existiert kein negativer Kreis $\bar{C}_{T,e}$, so ist $f$ eine optimale Lösung.\end{thm}
\begin{proof}Wir werden zeigen, dass ein negativer Kreis $\bar{C}_{T,e}$ existiert, wenn die betrachtete zulässige Baumlösung $(T,f)$ nicht optimal ist.
	
Sei $N=(G,b,c,u)$ ein Netzwerk mit einer optimalen zulässigen Baumlösung $(\hat{T},\hat{f})$ und einer zulässigen Baumlösung $(T,f)$, sodass $c(f)>c(\hat{f})$. Da $\hat{f}$ günstiger ist, existieren zwei verschiedene Knoten $x\neq y\in E(G)$, deren Weg $\hat{w}:=x\xrightarrow{\hat{T}}y$ günstiger ist als $w:=x\xrightarrow{T}y$. Der geschlossene Kantenzug $W:=x\xrightarrow{\hat{T}}y\xrightarrow{T}x$ besitzt damit Kosten $c(W)=c(\hat{w})-c(w)<0$. Zunächst sorgen wir dafür, dass aus dem geschlossenen Kantenzug mit negativen Kosten ein negativer Kreis wird.

$W$ kann in kantendisjunkte Kreise $C_1,\ldots,C_k$ zerlegt werden, womit auch die Kosten $c(W)=\sum_{i=1}^{k}c(C_i)$ aufgeteilt werden. Für jeden Kreis $C_i$ gibt es zwei Knoten $x_i\neq y_i$ mit $C_i=x_i\xrightarrow{\hat{T}}y_i\xrightarrow{T}x_i$. Da $c(W)<0$, existiert ein Kreis $C_j$ mit negativen Kosten. Wir werden im Folgenden nur noch $C_j$ betrachten, also können wir $C:=C_j$, $x:=x_j$ und $y:=y_j$ setzen.

Wir werden nun $C$ derart verändern, dass der Weg $x\xrightarrow{\hat{T}}y$ nur noch aus einer Kante $\hat{e}$ besteht. Dann ist $C=\bar{C}_{T,\hat{e}}$; für $c(C)<0$ sind wir fertig, andernfalls werden wir zwischendurch bereits einen negativen Kreis $\bar{C}_{T,e}$ gefunden haben.

TODO Bild

Betrachte einen Iterationsschritt mit negativen Kreis $C$, definiert durch die Knoten $x$ und $y$. Sei $e=(x,z)$ die erste und nicht einzige Kante des Weges $x\xrightarrow{\hat{T}}y$. Wir schauen uns nun den Weg $w:=x\xrightarrow{T}z$ und die beiden entstehenden Kreise $\tilde{C}:=x\xrightarrow{\hat{T}}z\xrightarrow{T}x$ und $C':=z\xrightarrow{\hat{T}}y\xrightarrow{T}z$ an. Sollte $c(\tilde{C})<0$ sein, ist $\tilde{C}=\bar{C}_{T,e}$ der gesuchte Kreis. Andernfalls ist im Kreis $C'$ der Wegteil über $\hat{T}$ um eine Kante gesunken; die Kosten $c(C')=c(C)-c(\tilde{C})\leq c(C)$ bleiben negativ. Besteht der Weg $z\xrightarrow{\hat{T}}y$ aus nur einer Kante, sind wir fertig, ansonsten setzen wir $C:=C'$ sowie $x:=z$ und iterieren weiter.

Da der Wegteil in $C$, der über $\hat{T}$ geht, nach jeder Iteration um eins kleiner wird, finden wir nach endlich vielen Iterationen einen negativen Kreis $\bar{C}_{T,e}$.\end{proof}

\begin{kor}\label{korrekt}Sei $N$ eine Instanz des Transportproblems mit einer zulässigen Initialbaumlösung $(T_0,f_0)$. Determiniert der Netzwerk-Simplex-Algorithmus, so ist er korrekt.\end{kor}

Bislang haben wir nicht gezeigt, dass der Algorithmus immer terminiert. Dies wäre offensichtlich, wenn bei jeder Iteration von $(T,f)$ zu $(T',f')$ die Kosten sinken würden, also $c(f')<c(f)$ wäre. Es gibt jedoch sogenannte \emph{degenerierte Iterationen}, in denen ein negativer Kreis $\bar{C}_{T,e}$ um $\delta=0$ augmentiert wird. Entfernt man danach eine Kante $e\neq e'\in C_{T,e}$, verändert sich nur der Baum. Der nächste Abschnitt beschäftigt sich damit, wie sichergestellt werden kann, dass der Algorithmus zumindest jeden Baum höchstens einmal betrachtet.

\subsection{Degenerierte Iterationen}\label{ch:deg}
TODO Bild degenerierte Iteration

\begin{defn}Wird in einer Iteration der Phase 2 des Netzwerk-Simplex-Algorithmus ein negativer Kreis $\bar{C}_{T,e}$ um $\delta=0$ augmentiert, so bezeichnen wir dies als \textbf{degenerierte Iteration}.
\end{defn}

Degenerierte Iterationen entstehen, wenn bei einer zulässigen Baumlösung $(T,f)$ nicht alle Kanten von $T$ Fluss aufweisen, also $T\neq T_f$ ist. $(T,f)$ wird dann auch als \emph{degeneriert} bezeichnet. In einer ungünstigen Konstellation von der deterministischen Wahl der hinzugefügten Kante $e$ und entfernten Kante $e'$ kann es zum \emph{Cycling} kommen, also zu einem Kreisschluss von Bäumen, die wiederholt iteriert werden. Dies tritt sehr selten auf, für ein künstlich konstruiertes Beispiel siehe \cite[S. 303]{NSAbook}.

\cite[Cunningham, 1976]{cycling} führte eine Methode ein, mit der Cycling verhindert werden kann, ohne dass die Wahl der hinzugefügten Kante $e$ eingeschränkt wird. Dafür benötigen wir folgende Definition:

\begin{defn}Sei $N=(G,b,c,u)$ eine Instanz des Transportproblems. Ein aufspannender Baum $T$ von $G$, ein maximaler Fluss $f$ auf $N$ und ein Wurzelknoten $r\in V(T)=V(G)$ bilden eine \textbf{stark zulässige Baumlösung} $(T,f)_r$, wenn $(T,f)$ eine zulässige Baumlösung ist und zusätzlich jede Kante $e=(v,w)\in E(T)$ mit $f(e)=0$ von der Wurzel weggerichtet, also $e$ im Weg $r\xrightarrow{T}w$ enthalten ist.\end{defn}

TODO erklären, was genau passiert. Tendenziell nicht beweisen.

Die Laufzeit des Netzwerk-Simplex-Algorithmus ist bislang ungeklärt. Für bestimmte Varianten wurden exponentielle Instanzen gefunden, die auf \emph{Stalling} basieren, also einer exponentiellen Anzahl degenerierter Iterationen. Mit diesen werden wir uns in \cref{ch:lit} näher befassen. Meine eigene, experimentelle Suche nach schlechten Instanzen findet sich in \cref{ch:erg}. Zunächst vervollständigen wir den Algorithmus um die Wahl des negativen Kreises $\bar{C}_{T,e}$ und die Erzeugung einer initialen Baumlösung.

\subsection{Pivotalgorithmen}\label{ch:pivot}
Sei $N=(G,b,c,u)$ ein Netzwerk mit zulässiger Baumlösung $(T,f)$. Algorithmen, die aus der Menge $\bar{C}_T=\{\bar{C}_{T,e}| c(\bar{C}_{T,e})<0)\}$ aller möglichen Iterationen eine auswählen, heißen \emph{Pivotalgorithmen}. In der Praxis wird der Pivotalgorithmus nur auf einer Teilmenge von $\bar{C}_T$ ausgeführt, um Rechenzeit zu sparen. In dieser Bachelorarbeit werden nur drei naheliegende, einfache Pivotalgorithmen betrachtet.

\subsubsection{Maximum Value}
Der erste Ansatz ist es, den negativsten Kreis zu wählen, sprich \begin{equation*}
\tilde{C}:=\argmin_{\bar{C}_{T,e}\in\bar{C}_T} \{c(\bar{C}_{T,e})\}
\end{equation*}
Diesen Weg werden wir mit \emph{MaxVal} bezeichnen.

\subsubsection{Maximum Revenue}
Die Kostenverringerung nach der Augmentierung beträgt $\delta\cdot c(\bar{C}_{T,e})$, ist also von $\delta$ abhängt. Der Pivotalgorithmus \emph{MaxRev} maximiert diesen Wert:
\begin{flalign*}
&&\tilde{C}:=\argmin_{\bar{C}_{T,e}\in\bar{C}_T} \{\delta_e\cdot c(\bar{C}_{T,e})\}
&&\delta_e:=\min_{e\in \bar{C}_{T,e}}\{\bar{u}(e)-\bar{f}(e)\}
\end{flalign*}
Nach \cref{negKreis} ist jedes $\delta_e$ endlich. Sollten nur degenerierte Iterationen zur Auswahl stehen, ist $c(\tilde{C})=0$. In dem Fall wendet meine konkrete Implementierung MaxVal an; hier sind aber auch andere Strategien denkbar.

\subsubsection{Random}
Ein überraschend effektiver Ansatz ist es, $\tilde{C}\in \bar{C}_T$ zufällig zu wählen. Gerade für diesen mit \emph{Random} bezeichneten Weg ist es schwierig, untere oder obere Schranken zu beweisen.

\subsection{Initialisierung} \label{ch:init}
Der letzte verbleibende Schritt, um einen vollständigen Algorithmus zur Lösung des Transportproblems zu erlangen, ist das Finden einer initialen, stark zulässigen Baumlösung $(T_0,f_0)_r$. Hierfür wenden wir einen Trick an:

Sei $N=(G,b,c,u)$ eine Instanz des Transportproblems. Wir fügen dem Netzwerk einen zusätzlichen Transitknoten $a$ mit $b(a)=0$ hinzu, den man als künstlichen \textit{(artificial)} Knoten bezeichnet. Für alle Quellen $v\in V(G):b(v)>0$ ergänzen wir eine künstliche Kante $(v,a)$, für alle Senken und Transitknoten $a\neq w\in V(G):b(w)\leq0$ eine künstliche Kante $(a,w)$. Sei $G'$ der entstehende Graph.

Sämtliche künstlichen Kanten $e_v$ haben eine unbegrenzte Kapazität, die wir mit $u(e_v)=\frac{1}{2}\cdot\sum_{v\in V(G)} |b(v)| + 1$ abschätzen. Die Kosten sind ebenfalls unendlich und können mit $c(e_v)=|V(G)|\cdot\max_{e\in E(G)}\{c(e)\}+1$ abgeschätzt werden, da jeder Weg in $G$ geringere Kosten aufweist. Leicht finden wir nun die stark zulässige Baumlösung $(T_0,f_0)_a$, wobei $T_0=(V(G),\{e_v|v\in V(G)\})$ ist. Nach \cref{TreeUnique} ist $f_0$ eindeutig.

Diese Art der Initialisierung werden wir im Folgenden mit \emph{HC} für \emph{High-Cost-Initialisierung} abkürzen.

\begin{lem}Sei $N=(G,b,c,u)$ eine Instanz des Transportproblems und $(T',f)$ die Lösung des Netzwerk-Simplex-Algorithmus mit \emph{HC} auf dem erweiterten Graphen $G'$. Die Instanz $N$ ist genau dann lösbar, wenn $G'_f$ keine künstlichen Kanten enthält.\end{lem}
\begin{proof}\label{solvable}$ $\par
\begin{description}[topsep=0pt]
	\item[\enquote{$\Rightarrow$}] Sei $\hat{f}$ ein maximaler Fluss von $N$ und $(T',f)$ die Lösung des Algorithmus. $\hat{f}$ ist auch ein maximaler Fluss des Netzwerkes $(G',b,c,u)$; damit gilt nach \cref{BLex} und \cref{korrekt} $c(f)\leq c(\hat{f})<\infty$. Da die Kosten einer künstlichen Kante äquivalent zu unendlich sind, kann keine davon in $G'_f$ enthalten sein.
	
	\item[\enquote{$\Leftarrow$}] Sei $(T',f)$ die Lösung des Algorithmus. Wenn $G'_f$ keine künstlichen Kanten enthält, ist $f_{|E(G)}$ ein maximaler Fluss von $N$, womit diese Instanz wiederum lösbar ist.
\end{description}
\end{proof}

Betrachtet man Instanzen mit vielen Knoten oder hohen Kosten der teuersten Kante, so kann es passieren, dass die Kosten der künstlichen Kanten den darstellbaren Bereich der gängigen Datentypen sprengen. Unter anderem aus diesem Grund gibt es die \emph{Low-Cost-Initialisierung}, bei uns kurz \emph{LC}.

Bei dieser wird die gegebene Instanz $N=(G,b,c,u)$ des Transportproblems zunächst zu $N'=(G,b,c',u)$ abgewandelt. Dabei ist $c'$ die Nullfunktion, also $c(e)=0$ für jede Kante $e\in E(G)$. Für $N'$ verwenden wir den Netzwerk-Simplex-Algorithmus mit \emph{HC} und erhalten eine stark zulässige Baumlösung $(T',f')_a$, wobei die Kosten einer künstlichen Kante $c(e_v)=|V(G)|\cdot0+1=1$ betragen.

Offensichtlicherweise ist $N$ genau dann lösbar, wenn $N'$ lösbar ist. Wenn $c(f')>0$ ist, so ist $N$ nicht lösbar und wir sind fertig. Andernfalls iterieren wir $(T',f')_a$ degeneriert, bis $a$ ein Blatt von $T'$ ist. Dies wird in \cref{HCLC} detailliert erläutert.

Damit bekommen wir die zulässige Baumlösung $(T=T'_{|V(G)}, f=f'_{|E(G)})$ für $N'$ und damit für $N$. Auch wenn der künstliche Knoten $a$ nicht in $G$ enthalten ist, können wir ihn trotzdem implizit als Wurzelknoten für die stark zulässige Baumlösung $(T,f)_a$ benutzen, da die künstlichen Kanten für den weiteren Verlauf des Algorithmus keine Rolle mehr spielen.

\section{Erweiterung auf beschränkte Kapazitäten}\label{ch:alg2}

\newpage
\chapter{Implementierung} \label{ch:prog}
Hier beginnt mein schönes Werk \ldots

\section{Netzwerke}
Residual explizit ohne wandelnde Kapazität

\section{Die Klasse \emph{Circle}}
Magie des updaten

\section{Stark zulässige Baumlösungen}
Öhm, ja \ldots

\section{Pivotalgorithmen}
Sehr kurz? Probably nur Code

\section{Initialisierung}\label{HCLC}
Beweis LC

\newpage
\chapter{Exponentielle Instanzen aus der Literatur}\label{ch:lit}

\newpage
\chapter{Experimentelle Ergebnisse}\label{ch:erg}
Meh.

\newpage
\chapter{Ausblick}
La la la.

\bibliography{bibliography}{}
\bibliographystyle{ieeetr}

\end{document}